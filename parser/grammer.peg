{
package parser

import (
    "fmt"

    "github.com/maniartech/uexl_go/ast"
)
}

/////////////////// Expressions //////////////////////

Input <- expr:Expr EOF {
  cntCodeBlocks++
  return expr, nil
}

Expr <- _ first:Term rest:( _ LogOp _ Term )* _ {
  cntCodeBlocks++

  // Expr:
  return ast.ParseExpression(string(c.text), first, rest, c.pos.offset, c.pos.line, c.pos.col)
}

Term <- first:Bit rest:( _ CmpOp _ Bit )* {
  cntCodeBlocks++

  // fmt.Println("Term:", first, rest)
  return ast.ParseExpression(string(c.text), first, rest, c.pos.offset, c.pos.line, c.pos.col)
}

Bit <- first:Shift rest:( _ BitOp _ Shift )* {
  cntCodeBlocks++

  // fmt.Println("Bit:", first, rest)
  return ast.ParseExpression(string(c.text), first, rest, c.pos.offset, c.pos.line, c.pos.col)
}

Shift <- first:Sum rest: ( _ ShiftOp _ Sum )* {
  cntCodeBlocks++

  // fmt.Println("Shift:", first, rest)
  return ast.ParseExpression(string(c.text), first, rest, c.pos.offset, c.pos.line, c.pos.col)
}

Sum <- first:Mul rest:( _ AddOp _ Mul )* {
  cntCodeBlocks++

  // fmt.Println("Sum:", first, rest)
  return ast.ParseExpression(string(c.text), first, rest, c.pos.offset, c.pos.line, c.pos.col)
}

Mul <- first:Mod rest:( _ MulOp _ Mod )* {
  cntCodeBlocks++

  // fmt.Println("Mul:", first, rest)
  return ast.ParseExpression(string(c.text), first, rest, c.pos.offset, c.pos.line, c.pos.col)
}

Mod <- first:Factor rest:( _ ModOp _ Factor )* {
  cntCodeBlocks++

  // fmt.Println("Mod:", first, rest)
  return ast.ParseExpression(string(c.text), first, rest, c.pos.offset, c.pos.line, c.pos.col)
}

Factor <- '(' expr:Expr ')' {
  cntCodeBlocks++
  return expr, nil
} / value:Value {
  cntCodeBlocks++
  return value, nil
}

//////////////// Operators Definitions //////////////////////

AddOp <- ( '+' / '-' ) {
  cntCodeBlocks++
  return string(c.text), nil
}

MulOp <- ( '*' / '/' ) {
  cntCodeBlocks++
  return string(c.text), nil
}

ModOp <- ( "//" ) {
  cntCodeBlocks++
  return string(c.text), nil
}

CmpOp <- ( "==" / "!=" / "<=" / ">=" / '<' / '>' ) {
  cntCodeBlocks++
  return string(c.text), nil
}

BitOp <- ( '&' / '|' / '^' ) {
  cntCodeBlocks++
  return string(c.text), nil
}

LogOp <- ( "&&" / "||" ) {
  cntCodeBlocks++
  return string(c.text), nil
}

ShiftOp <- ( "<<" / ">>") {
  cntCodeBlocks++
  return string(c.text), nil
}

Value <- val:( Number / Bool / Null / String / Array / Object ) {
    return val, nil
}

///////////////////// Number /////////////////////

Number <- Integer ( '.' DecimalDigit+ )? Exponent? {
  node, err := ast.NewNumberNode(
    string(c.text), c.pos.offset, c.pos.line, c.pos.col,
  )
	return node, err
}

Integer <- [+-]? DecimalDigit+ {
  return strconv.Atoi(string(c.text))
}

Exponent <- 'e'i [+-]? DecimalDigit+

DecimalDigit <- [0-9]

HexDigit <- [0-9a-f]i

///////////////////// Boolean /////////////////////

Bool <- ( "true" / "false") {
  cntCodeBlocks++
  return ast.NewBooleanNode(string(c.text), c.pos.offset, c.pos.line, c.pos.col)
}

///////////////////// Null /////////////////////

Null <- ( "null" ) {
  cntCodeBlocks++
  return ast.NewNullNode(string(c.text), c.pos.offset, c.pos.line, c.pos.col)
}

///////////////////// String /////////////////////

String <- DoubleQuoteString / SingleQuoteString

DoubleQuoteString <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
    c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
    value, _ := strconv.Unquote(string(c.text))
    return ast.NewStringNode(value, c.pos.offset, c.pos.line, c.pos.col)
}

SingleQuoteString <- "'" str:PlainString "'" {
    return ast.NewStringNode(string(c.text), c.pos.offset, c.pos.line, c.pos.col)
}

PlainString <- ( !EscapedChar . / '\\' EscapeSequence )* {
    c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
    return string(c.text), nil
}

EscapedChar <- [\x00-\x1f"'\\]

EscapeSequence <- SingleCharEscape / UnicodeEscape

SingleCharEscape <- ["\\/bfnrt]

UnicodeEscape <- 'u' HexDigit HexDigit HexDigit HexDigit

////////////////////// Array //////////////////////

Array <- '[' _ vals:( Expr ( ',' _ Expr )* )? ']' {
    valsSl := ast.ToIfaceSlice(vals)

    for _, x := range valsSl {
      fmt.Println(x)
    }

    if len(valsSl) == 0 {
      return ast.NewArrayNode(fmt.Sprintf("%v", vals), []ast.Node{}, c.pos.offset, c.pos.line, c.pos.col)
    }
    res := []interface{}{valsSl[0]}
    restSl := ast.ToIfaceSlice(valsSl[1])
    for _, v := range restSl {
      vSl := ast.ToIfaceSlice(v)
      res = append(res, vSl[2])
    }
    return ast.NewArrayNode(fmt.Sprintf("%v", vals), ast.ToNodesSlice(res), c.pos.offset, c.pos.line, c.pos.col)
}

Object <- '{' _ vals:( String _ ':' _ Expr ( ',' _ String _ ':' _ Expr )* )? '}' {
    valsSl := ast.ToIfaceSlice(vals)
    res := make([]ast.ObjectItem, 0, len(valsSl))
    if len(valsSl) == 0 {
        return ast.NewObjectNode(string(c.text), res, c.pos.offset, c.pos.line, c.pos.col)
    }
    res = append(res, ast.ObjectItem{ Key: valsSl[0].(ast.StringNode).Value, Value: valsSl[4].(ast.Node) })

    restSl := ast.ToIfaceSlice(valsSl[5])
    for _, v := range restSl {
        vSl := ast.ToIfaceSlice(v)
        res = append(res, ast.ObjectItem{ Key: vSl[2].(ast.StringNode).Value, Value: vSl[6].(ast.Node) })
    }
    return ast.NewObjectNode(string(c.text), res, c.pos.offset, c.pos.line, c.pos.col)
}

////////////////////// Whitespace //////////////////////

_ "whitespace" <- [ \n\t\r]*

////////////////////// EOF //////////////////////

EOF <- !.
